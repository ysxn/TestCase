
package com.codezyw.common;

/**
 * 常用排序算法 常用的排序算法的时间复杂度和空间复杂度<br>
 * 排序法<br>
 * 
 * <pre>
 *          最差时间分析         平均时间复杂度           稳定度             空间复杂度
 * 冒泡排序                 O(n2)       O(n2)       稳定              O(1)
 * 快速排序                 O(n2)       O(n*log2n)  不稳定          O(log2n)~O(n)
 * 选择排序                 O(n2)       O(n2)       稳定              O(1)
 * 二叉树排序             O(n2)       O(n*log2n)  不一顶        O(n)
 * 插入排序                 O(n2)       O(n2)       稳定              O(1)
 * 堆排序                      O(n*log2n)  O(n*log2n)  不稳定         O(1)
 * 希尔排序                  O           O          不稳定             O(1)
 * </pre>
 * 
 * 1、时间复杂度
 * <p>
 * （1）时间频度
 * 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多
 * ，哪个算法花费的时间少就可以了
 * 。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度
 * 。记为T(n)。
 * <p>
 * （2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，
 * 我们引入时间复杂度概念。
 * 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，
 * T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n))
 * 为算法的渐进时间复杂度，简称时间复杂度。
 * 在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同
 * ，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。
 * 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n),
 * 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...，
 * k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 2、空间复杂度
 * 与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: S(n)=O(f(n))
 * 我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。讨论方法与时间复杂度类似，不再赘述。
 * <p>
 * （3）渐进时间复杂度评价算法时间性能 　　主要用算法时间复杂度的数量级(即算法的渐近时间复杂度)评价一个算法的时间性能。
 * <p>
 * 2、类似于时间复杂度的讨论，一个算法的空间复杂度(Space
 * Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。 空间复杂度(Space
 * Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，
 * 算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面
 * 。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的
 * ，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比
 * ，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异
 * ，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地/
 * "进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况
 * 。
 * <p>
 * 如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(
 * 10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，
 * 即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。
 */
public class SortHelper {
    public static int swap;
    public static int a[] = {
            2, 6, 9, 4, 1, 0, 7, 3
    };

    /**
     * 冒泡排序是一种用时间换空间的排序方法，最坏情况是把顺序的排列变成逆序，或者把逆序的数列变成顺序。在这种情况下，每一次比较都需要进行交换运算。
     * 举个例子来说，一个数列 5 4 3 2 1 进行冒泡升序排列，<br>
     * 第一次大循环从第一个数（5）开始到倒数第二个数（2）结束，<br>
     * 比较过程：先比较5和4，4比5小，交换位置变成4 5 3 2 1；<br>
     * 比较5和3，3比5小，交换位置变成4 3 5 2 1……最后比较5和1，1比5小，交换位置变成4 3 2 1 5。<br>
     * 这时候共进行了4次比较交换运算，最后1个数变成了数列最大数。 <br>
     * 第二次大循环从第一个数（4）开始到倒数第三个数（2）结束。<br>
     * 进行3次比较交换运算。 <br>
     * …… <br>
     * 所以总的比较次数为 4 + 3 + 2 + 1 = 10次 <br>
     * 对于n位的数列则有比较次数为 (n-1) + (n-2) + ... + 1 = n * (n - 1) / 2，<br>
     * 这就得到了最大的比较次数 而O(N^2)表示的是复杂度的数量级。<br>
     * 举个例子来说，如果n = 10000，那么 n(n-1)/2 = (n^2 - n) / 2 = (100000000 - 10000) / 2，<br>
     * 相对10^8来说，10000小的可以忽略不计了，<br>
     * 所以总计算次数约为0.5 * N^2。用O(N^2)就表示了其数量级（忽略前面系数0.5）。
     */

    /**
     * 冒泡排序 从小到大升序
     */
    public static void bubbleSortAscending() {
        for (int j = a.length - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (a[i] > a[i + 1]) {
                    swap = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = swap;
                }
            }
        }
    }

    /**
     * 冒泡排序 从大到小降序
     */
    public static void bubbleSortDescending() {
        for (int j = 0; j < a.length - 1; j++) {
            for (int i = 0; i < a.length - j - 1; i++) {
                if (a[i] < a[i + 1]) {
                    swap = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = swap;
                }
            }
        }
    }

    /**
     * 冒泡排序 从小到大
     */
    public static void bubbleSortAscending2() {
        for (int j = 0; j < a.length - 1; j++) {
            for (int i = j + 1; i < a.length; i++) {
                if (a[i] < a[j]) {
                    swap = a[i];
                    a[i] = a[j];
                    a[j] = swap;
                }
            }
        }
    }

    /**
     * 插入排序 从大到小
     */
    public static void insertSortDescending() {
        for (int j = 1; j < a.length; j++) {
            for (int i = j; (i > 0) && a[i] > a[i - 1]; i--) {
                swap = a[i];
                a[i] = a[i - 1];
                a[i - 1] = swap;
            }
        }
    }

    /**
     * 递归排序之快速排序 从小到大 QuickSort(a, 0, a.length);
     * 
     * @param a
     * @param first
     * @param end
     */
    public static void quickSort(int[] a, int first, int end) {
        int mid = (first + end) / 2;
        swapData(a, first, mid);
        int scanA = first + 1;
        int scanB = end - 1;
        while (scanA < scanB) {
            if (a[scanA] > a[first] && a[scanB] < a[first]) {
                swapData(a, scanA, scanB);
                scanA++;
                scanB--;
            } else if (a[scanA] >= a[first]) {
                scanB--;
            } else if (a[scanB] <= a[first]) {
                scanA++;
            }
        }
        if (a[scanB] <= a[first]) {
            swapData(a, first, scanB);
            if (first < scanB - 1)
                quickSort(a, first, scanB);
            if (scanB + 1 < end - 1)
                quickSort(a, scanB + 1, end);
        } else {
            swapData(a, first, scanA - 1);
            if (first < scanA - 2)
                quickSort(a, first, scanA - 1);
            if (scanA < end - 1)
                quickSort(a, scanA, end);
        }
    }

    public static void swapData(int[] a, int i, int j) {
        swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
}
